#+TITLE: Systems

Integrant introduces the concept of a /system/, a collection of components that
has been initialized. Sweet Tooth's `sweet-tooth.endpoint.system` namespace
introduces some conveniences for dealing with systems:

- A multimethod `config` for naming integrant configs, like `:dev`,
  `:test`, etc.
- The `system` function, which lets you specify custom component configuration
  when it's called
- An `ig/init-key` alternative that allows a component's *configuration* to
  specify an alternative component implementation, possibly bypassing the
  `ig/init-key` implementation entirely. The namespace also introduces two kinds
  of component initialization alternatives, `replacement` and `shrubbery-mock`

Throughout these examples you'll see the namespace alias `es`, as in
`es/config`. This aliases `sweet-tooth.endpoint.system`.

* Named configs

The `sweet-tooth.endpoint.system` multimethod introduces a simple way to create
named integrant configs. Here's how it's used in the [[https://github.com/sweet-tooth-clojure/todo-example][the Sweet Tooth To-Do List
Example]]:

#+CAPTION: es/config example
#+BEGIN_SRC clojure
(ns sweet-tooth.todo-example.backend.duct
  (:require [clojure.java.io :as io]
            [duct.core :as duct]
            [sweet-tooth.endpoint.system :as es]))

(duct/load-hierarchy)

;;--------
;; Configs
;;--------
(defn read-config []
  (duct/read-config (io/resource "config.edn")))

(defn prep [& [profiles]]
  (duct/prep-config (read-config) profiles))

(defmethod es/config :test
  [_]
  (dissoc (prep [:duct.profile/test]) :duct.server.http/jetty))

(defmethod es/config :dev
  [_]
  (prep [:duct.profile/dev :duct.profile/local]))

(defmethod es/config :prod
  [_]
  (prep [:duct.profile/prod]))
#+END_SRC

A couple reasons to create a named config:

- You want to combine multiple profiles, as happens in the `:dev` config
- You want to `dissoc` components from a config, as in the `:test` profile.
  Duct's profile system is additive; when you combine profiles, you merge them,
  and there isn't a mechanism for removing component keys.

  The `:test` profile dissocs the `:duct.server.http/jetty` component so that
  starting a `:test` system doesn't start an HTTP server.

* `system`

The `system` function is the preferred way to initialize an integrant system.
Some features:

- It initializes a system using a named config.
- It lets you pass in a config map that gets merged with the custom config
- It makes testing easier
- It uses a custom init process (covered in the next section)

** Named systems

You call `system` like `(system :test)`.

The `system` function internally calls the `config` multimethod so that it can
pass a named config to Integrant. I've found it convenient to be able to call
`(es/system :test)` instead of something like `(ig/init (duct/prep-config
(duct/read-config (io/resource "config.edn") readers) [:test]))`

It's also been useful to consistently delineate all the different system
variations in one place.

** Custom configs

`system` takes a second argument, a component config that gets merged, kind of
like an anonymous profile. For example:

#+BEGIN_SRC clojure
(es/system :test {:duct.logger/timbre {:level :debug}})
#+END_SRC

This can be useful for troubleshooting. It can also be using when writing tests,
for example when you need to mock a component.

** Testing

Sweet Tooth's [[https://github.com/sweet-tooth-clojure/endpoint/blob/master/src/sweet_tooth/endpoint/test/harness.clj][test harness namespace]] relies on `es/system`, introducing the
`with-system` and `with-custom-system` macros, along with the `system-fixture`
function. This makes it easier to use test systems in your test.

Note that you can have more than one kind of test system: you might have one
named `:test` for unit tests where components for external services are mocked
out and one named `:integration` for integration tests where the external
components use sandbox environments.

* Custom `init` and `init-key`

The `sweet-tooth.endpoint.system` namespace introduces a replacement for
`init-key` that will /examine a component's configuration for alternative
implementations/. You can write a config like this:

#+CAPTION: mocking a component
#+BEGIN_SRC clojure
{::foo {::es/init-key-alternative ::es/shrubbery-mock}}
#+END_SRC

and when the `::foo` component is initialized, it will return a [[https://github.com/bguthrie/shrubbery][mock object
created by the shrubbery library]] instead of the component instance it would
normally return.

(There's also a `sweet-tooth.endpoint.system/init` function that differs from
Integrant's implementation only by calling the new `init-key` function rather
than Integrant's. `sweet-tooth.endpoint.system/system` uses
`sweet-tooth.endpoint.system/init`.)

The main motivation for introducing a custom `init-key` was to mock components.
In vanilla Integrant, there are two main ways to mock a component that I know
of:

- Make use of the keyword hierarchy. Have a live component `:foo/component` and
  `:foo/component-mock` that both derive from `:foo/component-type`, and have
  consumers use `(ig/ref :foo/component-type)` to refer to the type rather than
  a specific component name. Test configs include `:foo/component-mock` and
  non-test configs include `:foo/component`.
- Make the `ig/init-key` implementation of `:foo/component` dispatch on the
  configuration it's passed and return a mock object if something like `{:mock?
  true}` is present in the component's config.

Both of these approaches are ad-hoc and confusing. Introducing a consistent way
to inspect component configs and produce altnernative component makes it much
easier to see when you're creating a mock component, and it makes it possible to
handle mocking programatically, reducing the amount of boilerplate code you have
to write.

`sweet-tooth.endpoint.system/init-key` is very simple:

#+CAPTION: `sweet-tooth.endpoint.system/init-key`
#+BEGIN_SRC clojure
(defn init-key
  "Allows component _configuration_ to specify alterative component
  implementations."
  [k v]
  (or (init-key-alternative k v)
      (ig/init-key k v)))
#+END_SRC

The next sections will explain the `init-key-alternative` system and show you how
to use the two bundled alternatives, shrubbery mocks and replacements.

** `init-key-alternative`

`init-key-alternative` is a multimethod that returns an alternative
implementation of a component. Whereas `ig/init-key` dispatches on the /name/ of
the component, `init-key-alternative` dispatches on the /configuration/ of the
component. Specifically, it expects the component's configuration to be a map,
and it dispatches on the value of the
`:sweet-tooth.endpoint.system/init-key-alternative` key in that map. Let's show
how this works with a simple component.

#+CAPTION: a simple printing component
#+BEGIN_SRC clojure
(ns integrant-duct-example.init-key-alternative
  (:require [integrant.core :as ig]
            [sweet-tooth.endpoint.system :as es]
            [shrubbery.core :as shrub]))

(defmethod ig/init-key ::printer [_ {:keys [message]}]
  (prn (format "message: %s" message))
  {:message message})
#+END_SRC

If we initialize component with `ig/init-key`, it will print a little message
and return a map:

#+CAPTION: ig/init the printer
#+BEGIN_SRC clojure
(ig/init-key ::printer {:message "hi"})
"message: hi"
;; =>
{:message "hi"}
#+END_SRC

However, if we initialize the component with `es/init-key` and include a
key/value pair that `es/init-key-alternative` recognizes, we'll get something
different:

#+BEGIN_SRC clojure
(es/init-key ::printer {:message                  "hi"
                        ::es/init-key-alternative ::es/replacement
                        ::es/replacement          "bye"})
;; =>
"bye"
#+END_SRC

`:message "hi"` is still in the component config, but the message doesn't get
printed and the return value is `"bye"` instead of the map `{:message "hi"}`.

This happens because `es/init-key` calls the `es/init-key-alternative`
multimethod, which dispatches on the key `::es/init-key-alternative` in the
component's config. It finds the value `::es/replacement`, so it uses that
multimethod implementation:

#+CAPTION: `::es/replacement` implementation
#+BEGIN_SRC clojure
(defmethod init-key-alternative ::replacement
  [_ {:keys [::replacement]}]
  replacement)
#+END_SRC

As you can see, it returns the value of `::es/replacement`, which is `"bye"` in
the snippet above. (The multimethod references `::replacement` rather than
`::es/replacement` because it's defined from within the
`sweet-tooth.endpoint.system` namespace.)

Since `init-key-alternative` is a multimethod, you can extend it define your own
classes of component alternatives. Sweet Tooth comes with `::es/replacement`,
which you just saw, and `::es/shrubbery-mock`, which is used to create mock
objects with the shrubbery library.

** The `::es/shrubbery-mock` init-key alternative



** Duct config readers
