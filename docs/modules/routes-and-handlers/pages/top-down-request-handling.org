#+TITLE: Request Handling from the Top Down

This guide describes:

- The components involved in handling a requset
- The relationships between the components
- How duct composes the components
- How a request flows through the components

* Component Decomposition

Handling an HTTP request requires the coordination of multiple components.
This section breaks down high-level components into their subcomponents and
describes their relationships.

Check out my this diagram of the components involved in handling an API request
that looks like it was outsourced to a three year old:

.wow a very well-drawn architectural diagram
image::top-down-handlers.png[top down handlers]

The highest-level component is the /machine/ (1). When an HTTP request is sent,
the requestor's only expectation is that some machine - virtual private server
(VPS), Amazon EC2 instance, a lemon-powered raspberry pi - somewhere receives
the request and sends a response. It doesn't care about the machine's OS or what
processes are running.

The machine will be running a /database/ (2). It will also be running an HTTP
server (3). There's nothing special about HTTP servers; they're just some
program someone wrote, only they happen to listen for HTTP requests and send
HTTP responses.

For Clojure web apps, the HTTP server usually creates a /database connection/
(4). The HTTP server also contains a /request handler/ (5). In Clojure apps, the
request handler is just a function which takes a request and returns a response.

NOTE: the next couple paragraphs are a light overview of how a request gets
transformed at every stage of its journey from machine to HTTP server to Clojure
request handler. I'd love feedback on it: does it not provide enough detail?
Does it belong elsewhere?

The relationship between machine, HTTP server, and handler, is represented by
the boxes and lines at (6). The boxes are an interface that communicate with the
external world via some protocol. A protocol in this context is just some
agreed-upon format for structuring messages so that sender and receiver can
understand each other. The machine interface is an open port, typically port 80
or port 443, and communication happens via TCP/IP.

The HTTP server is some process running on the machine assigned to listen to
ports 80 and 443. It receives and sends messages that conform to the HTTP
protocol. Internally, the HTTP server converts the raw text of an HTTP message
into data structures that its supported programming languages understand. An
Apache server has modules for converting a message to PHP or Perl. A Ruby server
converts the message to some Ruby object.

Clojure is hosted on the JVM, and we use Java HTTP servers, most frequently a
library called Jetty. Jetty converts a request to a Java object. In Clojure, we
prefer to work with native Clojure maps and vectors, and developers most
frequently use the [[https://github.com/ring-clojure/ring][ring]] library to adapt the request for Clojure. It converts
the Java request object into [[https://github.com/ring-clojure/ring/wiki/Concepts#requests][a Clojure map]] with the keys `:uri`,
`:query-string`, `:request-method`, `:headers`, and `:body`, plus a few more.

Ring allows you to define a Clojure function to handle requests - we saw that at
(5). The request function takes a Ring request as an argument and should return
a response, which is a map with the keys `:status`, `:headers`, and `:body`.

You can write a function to construct a Ring response any way you want to, but
generally Ring request handlers are structured as a /middleware stack/ (7) and a
/router/ (8). The Ring request map passes through the middleware stack, which
transforms the request by adding, modifying, or removing the map's keys. The
ring request is then passed to the router, which routes the request, passing it
on to an /endpoint handler/ based on the request's path (e.g. `/topic/1`) and
method (`:get`, `:post`, etc).

Endpoint handlers typically perform CRUD (create, read, update, delete)
operations on a database, and have a reference to the database connection (9).

a flat config that composes these relationships

components mean there's an expected interface

components are interchangeable

you have to include the route table in the configuration
