= Server Architecture: Components and Beyond =
Daniel Higginbotham


This guide describes the architecture of Sweet Tooth API servers and the tools
used to implement the architecture. It covers:

* The components involved in handling a request
* The relationships among the components
* How https://github.com/duct-framework/core[Duct] and https://github.com/weavejester/integrant[Integrant] compose and manage the components
* How a request flows through the components

The term _component_ is super generic! It's siblings with _module_ and
_sub-system_ in the "nebulous programming terms" family. For our purposes a
component is "an instance of a computing thing that complies with an
_interface_." An "interface" is a set of rules for sending and receiving
messages, including both the transmission mechanism and the message structure.

For example, a _machine_ is a computing thing with a TCP/IP interface. An _HTTP
server_ is a computing thing with an HTTP interface. Let's look at these
components more closely.

[NOTE]
====

The "and Beyond" part of this guide's title is bs, but it's lovely bs.
There's a retail chain in America called _Bed Bath and Beyond_ and the "and
beyond" totally kills me. For some reason it sounds like they could make your
wildest dreams come true, but no, the "beyond" part is actually useless
Americana tchotchkes like a Mickey Mouse mini waffle maker.

Related: I once found a blow dryer at Target or whose packaging read something
like: "Good for drying hair AND SO MUCH MORE" and I sincerely hope the
copywriter enjoyed writing that. Thank you, noble soul, for reminding me that
all of life is full of wondrous possibility. Even everyday consumer goods
hold untold potential.

Sweet Tooth: good for writing single page apps AND SO MUCH MORE

====


== API Server Component Decomposition ==
Handling an HTTP request requires the coordination of multiple components.
This section breaks down high-level components into their subcomponents and
describes their relationships.

Check out my this diagram of the components involved in handling an API request
which looks like it was outsourced to a three year old:

.wow a very well-drawn architectural diagram
image::top-down-handlers.png[top down handlers]

The highest-level component is the _machine_ (1). When an HTTP request is sent,
the requestor's only expectation is that some machine - virtual private server
(VPS), Amazon EC2 instance, a lemon-powered raspberry pi - somewhere receives
the request and sends a response. It doesn't care about the machine's OS or what
processes are running.

The machine will be running a _database_ (2). It will also be running an HTTP
server (3). There's nothing special about HTTP servers; they're just some
program someone wrote, only they happen to listen for HTTP requests and send
HTTP responses.

For Clojure web apps, the HTTP server usually creates a _database connection_
(4). The HTTP server also contains a _request handler_ (5). In Clojure apps, the
request handler is just a function which takes a request and returns a response.

NOTE: the next couple paragraphs are a light overview of how a request gets
transformed at every stage of its journey from machine to HTTP server to Clojure
request handler. I'd love feedback on it: does it not provide enough detail?
Does it belong elsewhere?

The relationship between machine, HTTP server, and handler, is represented by
the boxes and lines at (6). The boxes represent an interface that communicate
with the external world via some protocol. A protocol in this context is just
some agreed-upon message structure that allows sender and receiver to understand
each other. The machine interface is an open port, typically port 80 or port
443, and communication happens via TCP/IP.

The HTTP server is some process running on the machine assigned to listen to
ports 80 and 443. It receives and sends messages that conform to the HTTP
protocol. Internally, the HTTP server converts the raw text of an HTTP message
into data structures that its supported programming languages understand. An
Apache server has modules for converting a message to PHP or Perl. A Ruby server
converts the message to some Ruby object.

Clojure is hosted on the JVM, and we use Java HTTP servers, most frequently a
library called Jetty. Jetty converts a request to a Java object. In Clojure, we
prefer to work with native Clojure maps and vectors, and developers most
frequently use the https://github.com/ring-clojure/ring[ring] library to adapt the request for Clojure. It converts
the Java request object into https://github.com/ring-clojure/ring/wiki/Concepts#requests[a Clojure map] with the keys `:uri`,
`:query-string`, `:request-method`, `:headers`, and `:body`, plus a few more.

Ring allows you to define a Clojure function to handle requests - we saw that at
(5). The request function takes a Ring request as an argument and should return
a response, which is a map with the keys `:status`, `:headers`, and `:body`.

You can write a function to construct a Ring response any way you want to, but
generally Ring request handlers are structured as a _middleware stack_ (7) and a
_router_ (8). The Ring request map passes through the middleware stack, which
transforms the request by adding, modifying, or removing the map's keys. The
ring request is then passed to the router, which routes the request, passing it
on to an _endpoint handler_ based on the request's path (e.g. `/topic/1`) and
method (`:get`, `:post`, etc).

Endpoint handlers typically perform CRUD (create, read, update, delete)
operations on a database, and therefore they typically have a reference to the
database connection (9).


== Component Definition, Composition, and Initialization with Integrant and Duct ==
Now that we know what components are involved in building an API server and how
those components are related to each others, let's turn our attention toward the
work we as developers have to do to _implement_ this architecture. Implementing
an architecture includes addressing how you _define_, _compose_, and
_initialize_ a system's components.

To *define* a component is to establish its responsibilities and its interface.
It also means choosing one or more language constructs to implement the notion
of "component".

In object-oriented languages this process feels more solid somehow: components
are defined by classes; the class's public methods are the interface and the
notion of "component" maps directly to classes. Things feel a bit more
loosey-goosey in Clojure land -- is a component a function? a namespace? a
record? -- but I'll introduce you to techniques for defining components shortly.

*Composing components*: how do components reference each other? The two main
approaches are to create a globally-accessible component that other components
reference directly from anywhere, or to follow the https://en.wikipedia.org/wiki/Dependency_injection#:~:text=In%20software%20engineering%2C%20dependency%20injection,object%20is%20called%20a%20service.[dependency injection pattern.]
You'll soon learn about how Sweet Tooth relies on the https://github.com/weavejester/integrant[Integrant] and https://github.com/duct-framework/core[Duct]
libraries, which implement dependency injection for Clojure apps.

*Initializing components* refers to the process of creating any objects or
state the component needs, and calling a function or method to start the
component. To initialize a request handler, you just create a function. To
initialize a database connection pool you create an instance of a connection
pool service, which might create some initial threads for db connections.

To get a Clojure API server running, you must first get a JVM process running.
Within that process, you must initialize components in dependency order:

* Initialize a database connection or connection pool
* Initialize a request handler that references the database connection
* Initialize an HTTP server with the request handler

[NOTE]
====

What does it mean to "initialize an HTTP server" from within a JVM process? If
you're familiar with programs like Apache or nginx, you might be used to
thinking of an HTTP server as a program that you launch from the command line,
not as something that you start from within the process of a program you're
writing.

The thing is, anyone can just write a program that starts listening to a port.
The tools are readily available. If you use your programming language's standard
libary to start listening for messages on a port and responding,
congratulations: you've created a server!

Now if you care about things like performance and resilience, you'll have to get
a bit fancier. That's why we have HTTP server libriaries. In the Java world,
one of the most popular libraries is Jetty. It adds some structure to how HTTP
requests are handled, and it takes care of managing resources like threads.

Initializing a Jetty server in your JVM process is basically a matter of
creating an `org.eclipse.jetty.server.Server` object and calling its `start`
method.

====

You could easily write something like this pseudocode to define, compose, and
initialize your system's components:

[source,clojure]
."start a server" pseudocode
----
(def db-connection (create-connection))
(defn handler [req] (update-db db-connection))
(defn start-server [] (run-jetty handler {:port 3000}))

(start-server)
----

I've seen plenty of Clojure API servers with code that looks like that, and that
approach works fine.

As I've mentioned like a billion times now, Sweet Tooth uses Integrant and Duct
to manage these architectural concerns. We'll first look at Integrant, because
it provides the foundation. Then we'll look at Duct, a layer on top of Integrant
that 1) makes it easier to create bundles of components to share and 2) makes it
easy to configure components for different environments (dev, test, prod, etc).

So let's look at Integrant so that you won't have to listen to me say "In a
minute we're going to look at Integrant" anymore.


== Integrant Tutorial ==
https://github.com/weavejester/integrant[Integrant] brings order to the practice of defining, composing, and initializing
components. It introduces two architectural abstractions: _systems_ and
_components_.

As defined above, a component is a computing thing that complies with an
interface. A _system_ is just the composition of all components needed for
whatever application or service you're trying to build. It's the outermost
container for all those cute little components.

All of this is a bit abstract; let's get concrete with some code:

[source,clojure]
.simple integrant example
----
(ns integrant-duct-example.basic-components
  (:require [integrant.core :as ig]))

(defmethod ig/init-key ::message-store [_ {:keys [message]}]
  (atom message))

(defmethod ig/init-key ::printer [_ {:keys [store]}]
  (prn (format "%s says: %s" ::printer store)))

(ig/init {::message-store {:message "love yourself, homie"}
          ::printer       {:store   (ig/ref ::message-store)}})
----

If you evaluate this code in a REPL, it will print the message,
`":integrant-duct-example.basic-components/printer says: love yourself, homie"`.
Let's work through it. The code, not loving yourself.

Integrant uses the multimethod `init-key` to initialize components. Components
are identified by a keyword; this example has components named `::message-store`
and `::printer`. The first argument to the multimethod is the component's name,
and the second argument is the component's configuration. The body of the
multimethod is the code for constructing and "running" a component. The return
value of `ig/init-key` is whatever construct (atom, object, clojure data
structure) you want other components to interact with.

For `::message-store` the configuration only includes a `:message`, but in real
systems configuration would include things like the port for an HTTP server to
listen to, the max number of threads for a thread pool, or the URI for a
database connection.

`::printer`'s configuration has the key `:store` and value `(ig/ref
::message-store)`. `(ig/ref)` produces an _integrant reference_ to the component
named `::message-store`. This makes it possible to pass the `::printer`
component the initialized `::message-store component`.

Integrant's `ig/init` function initializes a system. Its argument is a map whose
keys are component names, and whose values are the configuration for that
component. `ig/init` uses integrant references to initialize components in
dependency order. In the configuration above, the presence of `(ig/ref
::message-store)` in `::printer`'s configuration tells Integrant to initialize
the `::message-store` component before `::printer`. Then, when initializing
`::printer`, it replaces the `::message store` reference with the value returned
by `(ig/init-key ::message-store)`.

NOTE: The term _component_ is getting a little fuzzy here. I've been using it to
refer to a kind of coneptual entity that can be implemented in terms of a
definition and initialization process. But I'm also using it to refer to an
actual language object that is returned by `ig/init-key` and passed as an
argument to other components. Maybe one day I'll clear up that ambiguity, but
today is not that day. Sorry.

NOTE: Integrant includes a few other lifecycle methods for components:
`ig/halt!` and `ig/halt-key!`; `ig/suspend!` and `ig/suspend-key!`; plus a
couple more. Check out its https://github.com/weavejester/integrant[README] for more details.

We can see how Integrant helps us initialize (`ig/init`, `ig/init-key`) and
compose (`ig/ref`) components, but what about defining components? Earlier I
said,

#+begin_quote
To *define* a component is to establish its responsibilities and its interface.
It also means choosing one or more language constructs to implement the notion
of "component".
#+end_quote

`ig/init-key` does help to define a component in that it gives the component an
identity and imposes the constraint that a component be implemented as a single
thing that can get passed as a value to other components (which eliminates some
possibilities for defining components, like saying that namespace defines a
component.)

Integrant doesn't really prescribe what Clojure language constructs you use to
implement a component; the return value of `ig/init-key` can be whatever you
want.

That being said, it's common to define component interfaces using protocols and
to have `ig/init-key` return some object that implements the component's
protocols. There's some debate over whether or not it's a good idea to use
protocols in this context, and ultimately that choice is up to you. I personally
prefer protocols because they force me to make good design choices, and as a
side benefit they make testing easier. As a consequence Sweet Tooth provides
some useful tools for creating test mocks for components that take the protocol
approach.

TODO explain component design more.


=== Modularity Through Keyword Hierarchies ===
Integrant has an interesting feature that greatly expands its usefulness in
building composable systems, especially when it comes to building a framework
and building an ecosystem of framework components. Clojure allows you to create
create keyword hierarchies using `derive`, and Integrant takes advantage of this
when resolving component references created by `ig/ref`. Here's an example:

[source,clojure]
.using keyword hierarchies
----
(ns integrant-duct-example.hierarchy
  (:require [integrant.core :as ig]))

(defmethod ig/init-key ::message-store [_ {:keys [message]}]
  (atom message))

(defmethod ig/init-key ::printer [_ {:keys [store]}]
  (prn (format "%s says: %s" ::printer @store)))

(derive ::message-store ::store)

(ig/init {::message-store {:message "love yourself, homie"}
          ::printer       {:store   (ig/ref ::store)}})
----

The `::printer` component refers to a `::store` component. There are no
components named `::store`, but `::message-store` is derived from `::store`, so
Integrant uses that. This allows components to declare the _kind of_ components
they need to interact with, which makes it a lot easier to create modular
component libraries. The https://github.com/duct-framework/module.web[Duct web module], for example, https://github.com/duct-framework/module.web/blob/master/src/duct/module/web.clj#L54[configures its request
handler] as depending on a `:duct/router`. It doesn't provide any components
named `:duct/router`, but the Duct Ataraxy module will add a component named
`:duct.router/ataraxy`, which is derived from `:duct/router.` It's possible for
us to create our own router component and use that instead, as long as the
component's name is derived from `:duct/router`. In fact, that exactly what
Sweet Tooth does.


== notes to self ==
* describe architecture?
** the importance of boundaries and purpose in understanding a system
* component identification vs definition
* overloading the term "component" as both the concept that has its lifecycle
implemented, and the return value of one of the lifecycle methods
* TODO change "computing thing" to "resource" after writing framework notes
components mean there's an expected interface
components are interchangeable
you have to include the route table in the configuration
