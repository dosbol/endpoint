= Server Architecture: Components and Beyond =
Daniel Higginbotham


This guide describes the larger context of building an API server. Learning
about the higher-level pieces involved in handling API requests and how those
pieces fit together might not solve a specific problem you're facing, but it
will help you orient yourself as you navigate the programming terrain, so to
speak. (TODO work on this metaphor)

The guide covers:

* The components involved in handling a request
* The relationships among the components
* How https://github.com/duct-framework/core[duct] and https://github.com/weavejester/integrant[integrant] compose the components
* How a request flows through the components

The term _component_ is super generic! It's siblings with _module_ and
_sub-system_ in the "nebulous programming terms" family. For our purposes a
component is "an instance of a computing thing that complies with an
_interface_." An "interface" is a set of rules for sending and receiving
messages, including both the transmission mechanism and the message structure.

For example, a _machine_ is a computing thing with a TCP/IP interface. An _HTTP
server_ is a computing thing with an HTTP interface. Let's look at these
components more closely.

[NOTE]
====

The "and Beyond" part of this guide's title is bs, but it's lovely bs.
There's a retail chain in America called _Bed Bath and Beyond_ and the "and
beyond" totally kills me. For some reason it sounds like they could make your
wildest dreams come true, but no, the "beyond" part is actually useless
Americana tchotchkes like a Mickey Mouse mini waffle maker.

Related: I once found a blow dryer at Target or whose packaging read something
like: "Good for drying hair AND SO MUCH MORE" and I sincerely hope the
copywriter enjoyed writing that. Thank you, noble soul, for reminding me that
all of life is full of wondrous possibility. Even everyday consumer goods
hold untold potential.

Sweet Tooth: good for writing single page apps AND SO MUCH MORE

====


== Component Decomposition ==
Handling an HTTP request requires the coordination of multiple components.
This section breaks down high-level components into their subcomponents and
describes their relationships.

Check out my this diagram of the components involved in handling an API request
which looks like it was outsourced to a three year old:

.wow a very well-drawn architectural diagram
image::top-down-handlers.png[top down handlers]

The highest-level component is the _machine_ (1). When an HTTP request is sent,
the requestor's only expectation is that some machine - virtual private server
(VPS), Amazon EC2 instance, a lemon-powered raspberry pi - somewhere receives
the request and sends a response. It doesn't care about the machine's OS or what
processes are running.

The machine will be running a _database_ (2). It will also be running an HTTP
server (3). There's nothing special about HTTP servers; they're just some
program someone wrote, only they happen to listen for HTTP requests and send
HTTP responses.

For Clojure web apps, the HTTP server usually creates a _database connection_
(4). The HTTP server also contains a _request handler_ (5). In Clojure apps, the
request handler is just a function which takes a request and returns a response.

NOTE: the next couple paragraphs are a light overview of how a request gets
transformed at every stage of its journey from machine to HTTP server to Clojure
request handler. I'd love feedback on it: does it not provide enough detail?
Does it belong elsewhere?

The relationship between machine, HTTP server, and handler, is represented by
the boxes and lines at (6). The boxes represent an interface that communicate
with the external world via some protocol. A protocol in this context is just
some agreed-upon message structure that allows sender and receiver to understand
each other. The machine interface is an open port, typically port 80 or port
443, and communication happens via TCP/IP.

The HTTP server is some process running on the machine assigned to listen to
ports 80 and 443. It receives and sends messages that conform to the HTTP
protocol. Internally, the HTTP server converts the raw text of an HTTP message
into data structures that its supported programming languages understand. An
Apache server has modules for converting a message to PHP or Perl. A Ruby server
converts the message to some Ruby object.

Clojure is hosted on the JVM, and we use Java HTTP servers, most frequently a
library called Jetty. Jetty converts a request to a Java object. In Clojure, we
prefer to work with native Clojure maps and vectors, and developers most
frequently use the https://github.com/ring-clojure/ring[ring] library to adapt the request for Clojure. It converts
the Java request object into https://github.com/ring-clojure/ring/wiki/Concepts#requests[a Clojure map] with the keys `:uri`,
`:query-string`, `:request-method`, `:headers`, and `:body`, plus a few more.

Ring allows you to define a Clojure function to handle requests - we saw that at
(5). The request function takes a Ring request as an argument and should return
a response, which is a map with the keys `:status`, `:headers`, and `:body`.

You can write a function to construct a Ring response any way you want to, but
generally Ring request handlers are structured as a _middleware stack_ (7) and a
_router_ (8). The Ring request map passes through the middleware stack, which
transforms the request by adding, modifying, or removing the map's keys. The
ring request is then passed to the router, which routes the request, passing it
on to an _endpoint handler_ based on the request's path (e.g. `/topic/1`) and
method (`:get`, `:post`, etc).

Endpoint handlers typically perform CRUD (create, read, update, delete)
operations on a database, and therefore they typically have a reference to the
database connection (9).


== Component Composition with Duct ==
Building and running an API server requires the construction and composition of
disparate components. We'll focus only on the HTTP server component and its
subcomponents.

To get a Clojure API server running, you must first get a JVM process running.
Within that process, you must:

* Create a database connection or connection pool
* Create a request handler that references the database connection
* Initialize an HTTP server with the request handler

[NOTE]
====

What does it mean to "initialize an HTTP server" from within a JVM process? If
you're familiar with programs like Apache or nginx, you might be used to
thinking of an HTTP server as a program that you launch from the command line,
not as something that you start from within the process of a program you're
writing.

The thing is, anyone can just write a program that starts listening to a port.
The tools are readily available. If you use your programming language's standard
libary to start listening for messages on a port and responding,
congratulations: you've created a server!

Now if you care about things like performance and resilience, you'll have to get
a bit fancier. That's why we have HTTP server libriaries. In the Java world,
one of the most popular libraries is Jetty. It adds some structure to how HTTP
requests are handled, and it takes care of managing resources like threads.

Initializing a Jetty server in your JVM process is basically a matter of
creating an `org.eclipse.jetty.server.Server` object and calling its `start`
method.

====

To accomplish this, you could easily write something like this pseudocode:

[source,clojure]
."start a server" pseudocode
----
(start-server (handler (db-connection)))
----

I've seen plenty of Clojure API servers with code that looks like that, and
that approach works fine.

Sweet Tooth takes a different approach. It relies on the https://github.com/duct-framework/core[duct] and https://github.com/weavejester/integrant[integrant]
libraries to take a structured, methodical approach to initializing and
composing components.




Constructing and initializing these components isn't application-specific; it's
the kind of boilerplate a framework can take care of. Sweet Tooth relies on the
duct and integrant libraries.

Figuring out the specifics of exactly how to do this is something

* construct a server with minimal pieces
* it lives in java process
* component is an abstraction we impose
* sweet tooth uses duct because of its modularity
* what problems does duct solve?


The integrant library

a flat config that composes these relationships

components mean there's an expected interface

components are interchangeable

you have to include the route table in the configuration
